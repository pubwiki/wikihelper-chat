import { InMemoryTransport } from "@modelcontextprotocol/sdk/inMemory.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { readFileSync } from "fs";
/* eslint-disable n/no-missing-import */
import type { RegisteredTool } from "@modelcontextprotocol/sdk/server/mcp.js";
import type {
  TextContent,
  ToolAnnotations,
} from "@modelcontextprotocol/sdk/types.js";
import { experimental_createMCPClient as createMCPClient } from "ai";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";

export enum EditContentFormat {
  css = "sanitized-css",
  wikitext = "wikitext",
  lua = "Scribunto",
}

//for environments that do not support crypto.randomUUID() (e.g. NO HTTPS)
function uuidv4_fallback() {
  let uuid = "",
    i,
    random;
  for (i = 0; i < 32; i++) {
    random = (Math.random() * 16) | 0;
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += ((random & 3) | 8).toString(16);
    } else {
      uuid += random.toString(16);
    }
  }
  return uuid.replace(/^(.{8})(.{4})(.{4})(.{4})(.{12})$/, "$1-$2-$3-$4-$5");
}
const MCP_WIKIHELPER_URL = "https://mcp.pub.wiki/mcp";

export async function buildRawWikiMCPClient(
  headers: Record<string, string> = {}
) {
  const client = await createMCPClient({
    transport: new StreamableHTTPClientTransport(new URL(MCP_WIKIHELPER_URL), {
      requestInit: {
        headers,
      },
    }),
  });
  return client;
}

function minifyMediaWikiHTML(html: string) {
  return (
    html
      // ÂéªÊéâÊç¢Ë°åÂíåÂà∂Ë°®Á¨¶
      .replace(/[\n\r\t]+/g, "")
      // ÂéªÊéâÊ†áÁ≠æ‰πãÈó¥ÁöÑÂ§ö‰ΩôÁ©∫Ê†ºÔºà>   < -> ><Ôºâ
      .replace(/>\s+</g, "><")
      // ÂéªÊéâË°åÈ¶ñË°åÂ∞æÁöÑÂ§ö‰ΩôÁ©∫Ê†º
      .replace(/^\s+|\s+$/g, "")
      // ÂéãÁº©Ê†áÁ≠æÂ§ñÈÉ®ËøûÁª≠Á©∫Ê†ºÔºàÊ†áÁ≠æ‰πãÈó¥ÂèØËÉΩ‰ºöÊúâÂæàÂ§öÁ©∫Ê†ºÔºâ
      .replace(/\s{2,}/g, " ")
  );
}

function toNumber(value: string | undefined, defaultValue: any) {
  if (value === undefined) return defaultValue;
  const num = Number(value);
  return Number.isFinite(num) ? num : defaultValue;
}

export enum ContentFormat {
  noContent = "noContent",
  withSource = "withSource",
  withHtml = "withHtml",
}

const TOOL_PROMPTS: Record<string, z.ZodRawShape> = {
  "get-page": {
    server: z
      .string()
      .url()
      .describe(
        "the host URL of target wiki which you want to use for current session, it belike https://{WIKI_ID}.pub.wiki/ (e.g. https://somewhere.pub.wiki/)."
      ),
    title: z.string().describe("Wiki page title"),
    content: z
      .nativeEnum(ContentFormat)
      .describe("Format of the page content to retrieve")
      .optional()
      .default(ContentFormat.withSource),
  },
  "load-world": {
    server: z
      .string()
      .url()
      .describe(
        "the host URL of target wiki which you want to use for current session, it belike https://{WIKI_ID}.pub.wiki/ (e.g. https://somewhere.pub.wiki/)."
      ),
  },
  "upload-image": {
    server: z
      .string()
      .url()
      .describe(
        "the host URL of target wiki which you want to use for current session, it belike https://{WIKI_ID}.pub.wiki/ (e.g. https://somewhere.pub.wiki/)."
      ),
    url: z
      .string()
      .url()
      .describe(
        "Image URL to download, and it will be uploaded to the wiki,if image is generated by AI, please provide source URL"
      ),
    filename: z
      .string()
      .describe("Target file name on the wiki, e.g., Example.png"),
    comment: z.string().describe("Upload comment").optional(),
  },
  "list-all-page-titles": {
    server: z
      .string()
      .url()
      .describe(
        "the host URL of target wiki which you want to use for current session, it belike https://{WIKI_ID}.pub.wiki/ (e.g. https://somewhere.pub.wiki/)."
      ),
    limit: z
      .number()
      .min(1)
      .max(500)
      .optional()
      .describe("Maximum number of pages to return (1‚Äì500, default=50)."),
    apcontinue: z
      .string()
      .optional()
      .describe("Pagination token (apcontinue) to continue listing pages."),
    namespace: z
      .number()
      .optional()
      .describe(
        `Restrict results to a specific namespace (default=0 for main/articles).
				Common namespaces:
				- 0: Main (articles)
				- 1: Talk
				- 2: User
				- 3: User talk
				- 4: Project (e.g. Wikipedia:)
				- 6: File
				- 8: MediaWiki (system messages)
				- 10: Template
				- 12: Help
				- 14: Category
				- -1: Special (not editable)`
      ),
  },
  "set-target-wiki": {
    server: z
      .string()
      .url()
      .describe(
        "The host URL of the target wiki to be used for this session. Example: https://{WIKI_ID}.pub.wiki/ (e.g., https://somewhere.pub.wiki/)."
      ),
  },
};

function wrapTransportWithMeta(transport: Transport, headers: Record<string, string>): Transport {
  return new Proxy(transport, {
    get(target, prop, receiver) {
      if (prop === "send") {
        return async (msg: any) => {
          //console.log("Original message to send:", msg);
          if (msg && typeof msg === "object" && msg.method === "tools/call") {
            msg = {
              ...msg,
              params: {
                name: msg.params.name,
                _meta:{
                  headers
                },
                arguments:{
                  ...msg.params.arguments,
                },
              },
            };
          }
          return target.send(msg);
        };
      }
      // ÂÖ∂‰ªñÊñπÊ≥ïÂíåÂ±ûÊÄßÂéüÊ†∑ÈÄè‰º†
      return Reflect.get(target, prop, receiver);
    },
  });
}


export function BatchUploadPageTool(
  server: McpServer,
  tools: Record<string, any>
): RegisteredTool {
  return server.tool(
    "batch-upload-page",
    // üß† PromptÔºàÊèèËø∞‰ø°ÊÅØÔºâ
    "This tool is used when the assistant needs to upload or update **multiple wiki pages in a batch**. " +
      "Each item in the batch specifies a page title, edit type, file path, and optional section/comment. " +
      "‚ö†Ô∏è Important: Always call this tool only after explicit user approval. " +
      "Each page operation (create or update) will be executed independently, and partial successes are possible. " +
      "If you only want to change one page, use [upload-page] instead. " +
      "When editing, prefer providing a `section` identifier to make minimal edits instead of replacing the whole page. " +
      "The assistant should never assume the result without actual confirmation.",

    // üß© Schema ÂÆö‰πâ
    {
      server: z
        .string()
        .url()
        .describe(
          "The host URL of the target wiki for this session, e.g. https://{WIKI_ID}.pub.wiki/."
        ),
      items: z
        .array(
          z.object({
            editType: z
              .enum(["create", "update"])
              .describe("Whether to create or update this page."),
            title: z.string().describe("Wiki page title to be changed."),
            filePath: z
              .string()
              .describe("Local path to the prepared content file."),
            section: z
              .string()
              .describe(
                'Section identifier for incremental edits: "new" to add a section, "0" for the lead section, or an index like "1" or "2". ' +
                  'Use "all" to replace the entire page. Prefer section edits whenever possible.'
              )
              .optional(),
            comment: z.string().describe("Optional edit summary.").optional(),
            contentModel: z
              .nativeEnum(EditContentFormat)
              .describe(
                "Format of the page content. Default is 'wikitext'. " +
                  "For CSS pages use 'sanitized-css', and for Lua modules use 'Scribunto'."
              )
              .optional()
              .default(EditContentFormat.wikitext),
          })
        )
        .min(1)
        .describe("List of pages to upload or update in a single batch call."),
    },
    {
      title: "Batch Upload / Update Wiki Pages",
      readOnlyHint: true,
      destructiveHint: false,
    } as ToolAnnotations,

    async (args, extra) => { 
      const { items, server } = args;

      const { headers } = (extra._meta || {
        chatId: "unknown",
        headers: {},
      }) as { chatId: string; headers: Record<string, string> };

      const results: TextContent[] = [];

      for (const [index, item] of items.entries()) {
        const { title, filePath, comment, section, editType } = item;

        try {
          const content = readFileSync(filePath, "utf-8"); // todo: replace for your own filesystem access method
          const model =
            item.contentModel ||
            (title.endsWith("styles.css")
              ? EditContentFormat.css
              : title.startsWith("Module:")
              ? EditContentFormat.lua
              : EditContentFormat.wikitext);

          const sourceContent =
            model === EditContentFormat.wikitext &&
            title.startsWith("Template:")
              ? minifyMediaWikiHTML(content)
              : content;

          const callArgs = {
            server,
            source: sourceContent,
            title,
            comment,
            contentModel: model,
          } as any;

          if (editType === "update") {
            callArgs.section =
              section === "all"
                ? undefined
                : section === "new"
                ? "new"
                : toNumber(section, undefined);
          }

          const toolName =
            editType === "create" ? "create-page" : "update-page";

          const callResult = await tools[toolName].execute(callArgs, {
            toolCallId: uuidv4_fallback(),
            messages: [],
          });

          results.push({
            type: "text",
            text: `‚úÖ [${index + 1}/${
              items.length
            }] Page "${title}" ${editType} succeeded.`,
          });
          results.push(...((callResult.content ?? []) as TextContent[]));
        } catch (err) {
          results.push({
            type: "text",
            text: `‚ùå [${index + 1}/${items.length}] Error while processing "${
              item.title
            }": ${(err as Error).message}`,
          });
        }
      }

      return { content: results };
    }
  );
}

export async function buildWikiMCPClient(headers: Record<string, string> = {}) {
  const [server_transport, client_transport] =
    InMemoryTransport.createLinkedPair();
  const server = new McpServer({
    name: "built-in-user-interface",
    version: "1.0",
  });
  const client = await buildRawWikiMCPClient(headers);
  const tools = await client.tools();
  BatchUploadPageTool(server, tools);

  for (const toolName in tools) {
    const tool = tools[toolName];
    if (toolName in TOOL_PROMPTS) {
      server.tool(
        toolName,
        tool.description || `Tool: ${toolName}`, 
        TOOL_PROMPTS[toolName],
        async (args: any, extra: any) => {
          try {
            const result = await tool.execute(args, {
              toolCallId: uuidv4_fallback(),
              messages: [],
            });

            // Ensure the result has the correct format for MCP Server
            // The AI SDK result might not have the content array format
            if (result && typeof result === "object") {
              // If result already has content array, return as is
              if ("content" in result && Array.isArray(result.content)) {
                return result as any;
              }
              // Otherwise wrap it in a content array
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify(result, null, 2),
                  },
                ],
              };
            }

            // Fallback for unexpected result types
            return {
              content: [
                {
                  type: "text",
                  text: String(result),
                },
              ],
            };
          } catch (err) {
            throw err;
          }
        }
      );
    }
  }

  await server.connect(server_transport);

  const ret_client =await createMCPClient({
    transport: wrapTransportWithMeta(client_transport, headers),
  })

  return ret_client;
}

/*Example for langchain.js
const client = await buildWikiMCPClient();
const tools = loadMcpTools(client);
const agent = createAgent({
    model: "anthropic:claude-sonnet-4-5",
    tools,  
});
*/
